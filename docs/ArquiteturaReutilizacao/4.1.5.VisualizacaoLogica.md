# Diagrama de Classes
## Introdução à Modelagem Estática com UML

A UML (Unified Modeling Language) é uma linguagem padrão adotada internacionalmente para especificar, visualizar, construir e documentar artefatos de sistemas de software. Ela fornece um conjunto robusto de notações gráficas para modelar tanto aspectos estáticos quanto dinâmicos de sistemas complexos.

Na modelagem estática — foco deste módulo — os diagramas são utilizados para representar a **estrutura fixa** do sistema, como classes, objetos, atributos e os relacionamentos entre eles. Esta abordagem é essencial durante a fase de projeto, pois fornece uma visão clara da arquitetura do sistema e serve como base sólida para a implementação.

Uma boa documentação técnica é crucial para manter a consistência, facilitar a comunicação entre os membros da equipe e garantir a escalabilidade do sistema. Neste contexto, a utilização de diagramas de classe, como parte da modelagem estática, se mostra fundamental para a compreensão da lógica estrutural do projeto **EternaFGA**.

---

## 2.1.1 Diagrama de Classes – Sistema EternaFGA

O **diagrama de classes** é um dos diagramas mais importantes da UML, especialmente na modelagem orientada a objetos. Ele descreve as classes que compõem o sistema, seus atributos, métodos e os relacionamentos entre elas, revelando a estrutura lógica da aplicação.

No caso do sistema **EternaFGA**, o diagrama de classes modela os principais componentes responsáveis por armazenar e gerenciar as memórias da comunidade acadêmica, além de fornecer suporte a acessibilidade, curadoria de conteúdo e categorização.

A seguir, detalhamos as principais classes presentes no modelo:

## Diagrama de Classes

<iframe frameborder="0" style="width:100%;height:624px;" src="https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=Diagrama_Classes.drawio&dark=auto#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1ANLGoMSh-q9ZrjE9yx2yXLP4Js2I2G6r%26export%3Ddownload"></iframe>

### Classe `Usuario`

A classe `Usuario` representa qualquer pessoa que interage com o sistema, sendo a superclasse de `Administrador` e `Estudante`. Ela define os comportamentos básicos esperados de qualquer usuário da plataforma.

**Responsabilidades:**
- Enviar novas memórias.
- Visualizar memórias públicas.
- Pesquisar memórias por palavras-chave ou tags.
- Filtrar resultados com base em critérios definidos.
- Compartilhar memórias com terceiros.
- Criar, editar ou excluir coleções pessoais.

**Assinaturas de Métodos (Exemplos):**
```java
visualizarMemorias(): List<Memoria>
pesquisarMemorias(): List<Memoria>
filtrarMemorias(): List<Memoria>
compartilharMemoria(): boolean
```

## Classe `Administrador` (herda de `Usuario`)

O `Administrador` é um tipo de usuário com permissões privilegiadas. Ele é o responsável pela curadoria do conteúdo e manutenção da qualidade das memórias enviadas ao sistema.

### Responsabilidades adicionais:
- Aceitar ou rejeitar memórias enviadas.
- Editar e excluir memórias já publicadas.
- Criar, editar e excluir tags de categorização.
- Criar e editar coleções temáticas.
- Visualizar todas as memórias pendentes e enviadas.

### Assinaturas de Métodos:
```java
aceitarMemoria(m: Memoria): void
rejeitarMemoria(m: Memoria): void
criarTag(): void
excluirTag(): boolean
visualizarTags(): List<Tag>
consultarEnvios(): List<Memoria>
```

## Classe `Memoria`

A `Memoria` representa o principal recurso do sistema: uma lembrança registrada por um usuário da comunidade.

### Atributos:
- `titulo`: título da memória.
- `descricao`: texto descritivo.
- `status`: objeto da classe `Status`, indica se a memória foi aprovada ou não.
- `midias`: lista de objetos do tipo `MidiaDigital` (como imagem ou vídeo).
- `tags`: coleção de `Tags` associadas à memória.
- `autor`: referência ao usuário criador.
- `dataEnvio`: data do envio da memória.

### Relacionamentos:
- Uma memória pode conter **várias mídias**.
- Cada memória pode estar associada a **múltiplas tags**.
- Uma memória está vinculada a **um status** e **um autor**.

## Classe `Tag`

Tags são palavras-chave utilizadas para categorizar memórias, facilitando a busca e organização do conteúdo.

### Atributos:
- `id`: identificador único.
- `nome`: nome da tag.

### Relacionamentos:
- Relação N:N entre `Memoria` e `Tag`.

## Classe `Status`

Define o estado atual da memória (pendente, aprovada ou rejeitada).

### Atributos:
- `observacao`: justificativa ou anotação de curadoria.
- `aprovadaSimNao`: valor booleano representando a aprovação.

## Classe `MidiaDigital` e Subclasses

As mídias digitais complementam as memórias com elementos visuais e audiovisuais. Há herança entre `MidiaDigital` e suas subclasses `Imagem` e `Video`.

### Atributos em comum:
- `id`: identificador da mídia.
- `formato`: tipo de arquivo.
- `legenda`: descrição para acessibilidade.

### Subclasses:
- **`Imagem`**: inclui atributos como `urlArquivo`, `textoAlternativo`, `resolucao`.
- **`Video`**: inclui `urlArquivo` e `duracao`.

## Classe `Colecao`

Coleções organizam memórias em agrupamentos temáticos.

### Atributos:
- `tema`: tema da coleção.
- `descricao`: descrição da proposta.
- `autor`: usuário criador da coleção.

### Método:
```java
adicionarMemoria(memoria: Memoria): void
```

## Classe `Exposicao`

Uma `Exposicao` agrupa coleções e memórias selecionadas por curadores (administradores) para fins específicos, como eventos ou datas comemorativas.

### Atributos:
- `titulo`: título da exposição.
- `dataInicio`: data de início.
- `dataFim`: data de encerramento.
- `curador`: instância da classe `Administrador`.

## Classe `Sistema`

Controla funcionalidades de acessibilidade e preferências do usuário.

### Atributos:
- `vlibrasHabilitado`: booleano que ativa/desativa o VLibras.
- `contraste`: modo de contraste (alto/baixo).
- `tamanhoFonte`: tamanho da fonte ajustável.

### Métodos:
```java
ajustarContraste(): boolean
ajustarFonte(): int
habilitarVibras(): boolean
armazenarMemoria(): boolean
```

## Classe `Autenticador`

Gerencia a autenticação e a sessão dos usuários no sistema.

### Métodos principais:
```java
autenticarUsuario(login, senha): Usuario
autenticarAdmin(): void
terminarSessaoAtiva(): void
```

## Considerações Finais

O **diagrama de classes** do sistema **EternaFGA** oferece uma representação sólida e detalhada da estrutura estática da aplicação. Ele apoia tanto a etapa de desenvolvimento quanto a documentação formal do sistema, promovendo clareza e consistência.

A separação clara de responsabilidades entre classes, o uso estratégico de herança e agregações, e o suporte explícito a acessibilidade revelam uma arquitetura que prioriza a experiência do usuário e a valorização da memória institucional da FGA.

# Diagrama de Implantação 
## Introdução

O **Diagrama de Implantação**, como um diagrama estrutural da UML (Unified Modeling Language), é fundamental para representar a arquitetura física de um sistema. No entanto, sua análise transcende a mera ilustração de componentes de hardware e software; ele é uma janela para a **Visão Lógica subjacente da aplicação**. Ao detalhar as tecnologias empregadas, a distribuição do processamento e a interação entre artefatos, o diagrama de implantação não apenas descreve **"como"** o sistema é construído, mas também insinua **"o quê"** ele faz e **"por que"** foi projetado dessa maneira.

## Visão Geral da Arquitetura: Uma Abordagem em Camadas para a Eterna FGA

A aplicação **Eterna FGA** é estruturada sob uma arquitetura **cliente-servidor baseada em web**, composta por três camadas principais:

- **Camada de Apresentação (FrontEnd)**
- **Camada de Lógica de Negócios (Backend)**
- **Camada de Persistência de Dados (Banco de Dados)**

Essa divisão é baseada em princípios sólidos de design de software, que promovem **escalabilidade, segurança, manutenibilidade e reutilização**. O acesso universal via protocolo HTTPS por dispositivos como computadores e smartphones comprova a eficácia desta estrutura.

<p align="center"><strong>Figura 1 – Diagrama de Implantação da aplicação Eterna FGA</strong></p>

<p align="center">
    <iframe frameborder="0" style="width:10%; height:900px;"
        src="https://viewer.diagrams.net/?tags=%7B%7D&lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=Diagrama_Implanta%C3%A7%C3%A3o.drawio&dark=auto#R%3Cmxfile%3E%3Cdiagram%20name%3D%22P%C3%A1gina-1%22%20id%3D%22E7zcgk4AevlYPmeYEHd9%22%3E5Vrbcto6FP0aHpvxlcBjubVzDjlDCzNNnzrCFrZ6jOSRxS1fX8mWsFXZCWnT2DQvibR1s9bae22zoeeOt8cPFKTxHQlh0nOs8NhzJz3HsR3f5v%2BE5VRYbi2vMEQUhXJSaViiByiNlrTuUAgzbSIjJGEo1Y0BwRgGTLMBSslBn7YhiX5qCiJoGJYBSEzrFxSyuLAOnNvS%2FhGiKFYn2%2F1hMbIFarK8SRaDkBwqJnfac8eUEFa0tscxTAR4Cpdi3axh9PxgFGJ2yYLZ4PvgnwcvOdzPv%2BHZ3fSe7v99Z%2Fflw7GTujEMOQCySyiLSUQwSKaldUTJDodQbGvxXjlnTkjKjTY3foeMnSSbYMcIN8Vsm8hRiMP3ghvexQSLLTMGKJuhJJGbmpeT983IjgbwkRtJ9%2BL7RZA9dnO%2FmCiuWzlBYvcBki1k9MQnUJgAhva6PwDpVtF5Xok8b0jwn0GEJzfeg2Qnj1qNF7XkzMGaB5kGKEhQhHk74HBByg17SBniXvxeDmxRGBbcwQw9gHW%2BnwA6JQiz%2FDL%2BqOdPaqF%2F1HPESfDYq4lFeYrm7hqyctU768ZyJG1SJRSLF2MvN1%2BI21SmkM0m417wMznnZ%2Fh1vmzH4MsgK%2BKBkjZ68u8D5w4tDTVbSc2hVCp7IG1xVaXUxBd3Y9dAZQnpHoWEcuuMEsymODSA%2BtlbmdCRs1MncMOERKQgQDha5RozKA3zfHjilJbP8qZ2botBKo4JdutcaApNsoXvh4hytBERh3BdEZCNNvwRlfp5epAdYsTgkh8hxg483T0jWJwGzk1u2%2BNuaHD3GYKAGWwpRLck3OWaUk%2BU4sW6RJ8KxusQrhDw8mDL0b4eR%2F2aMLJqqPD%2FFBO2%2B7dlZffCrOx1Kim7psh%2FXK0Wyy6nZaXAL5GW7c5nYVOzWs%2FCbvtZ2DNQGYHgfygybx9sharidVamrzeViYcNvHcpE9u3NW7dT1iO1J43I9H8b7pcKTM%2FpjJyfSn7clbqU7bfdspWvtAlJfIdv20lUp%2ByNSnCAREVIcj%2FTEBIsrenQmdv6bQKDQzuFiRjEYXLT%2FOrk5hnQN4gMTXB9LoSY5aIXl1ifB0Tu%2FVXHfMNfTF%2Bg3rSRHCn9MRMkSNRoOehf3Vicjne9YHTeonBMT8jtC0mXVAT83VlgrKUZIh%2F%2FhUvLXdkjfjl3p7AeA2kd0lgnL7B3tUKzOV4d1RgXN8A%2FTVqmEfE7ivtr2KrG1%2F2Jke5c945qQ7m972vdr5WO%2Fmivn%2FuimXCsWV%2FASniiAmPyNfkNdMn6qhmpbVRZZ%2BsrCqnf7K0KguDXSmtmpW7rpdWlUf%2FfuLjHjl0JR%2FdLa66t9cXwTeeP9Ci%2BGY49LRItrRAbgzjP%2FlliHrPubaQNesBnQ9ZVUh9iZD1HC3DtvjlCO%2BWvxsqppe%2FvnKnPwA%3D%3C%2Fdiagram%3E%3C%2Fmxfile%3E">
    </iframe>
</p>

## Análise Lógica por Componente

### PC e Dispositivo Móvel (Camada de Apresentação/Acesso)

- **Função:** Porta de entrada da experiência do usuário.
- **Interface:** Navegadores (Browsers) que consomem os serviços da aplicação.
- **Lógica:** Responsável por traduzir ações do usuário em requisições HTTP para o servidor.
- **Segurança:** Utilização de **HTTPS** garante criptografia e integridade dos dados.
- **Responsabilidade:** Encapsular a **UI/UX** e apresentar as funcionalidades como visualização, busca e envio de memórias.

### Servidor FrontEnd (Camada de Apresentação/Renderização)

- **Tecnologia:** React.
- **Função:** Renderização de interface, gerenciamento da lógica de apresentação.
- **Arquitetura:** Permite aplicações **SPA (Single Page Application)** ou **PWA (Progressive Web Application)**.
- **Separação de responsabilidades:** Foca na interação com o usuário, delegando a lógica de negócio ao Backend.
- **Segurança:** Comunicação segura com Backend via HTTPS.

### Backend (Camada de Lógica de Negócios/Serviços)

- **Tecnologia:** NestJS (TypeScript).
- **Responsabilidades:**
  - Implementar regras de negócio.
  - Gerenciar estado da aplicação.
  - Autenticar/autorização de usuários.
  - Expor APIs via HTTPS.
  - Abstrair o acesso ao banco de dados.
- **Design patterns aplicados:**
  - Inversão de Controle (IoC)
  - Injeção de Dependência (DI)
- **Modularidade:** Arquitetura escalável, desacoplada e testável.

### Banco de Dados (Camada de Persistência)

- **Tecnologia:** PostgreSQL.
- **Função:** Armazenamento e recuperação eficiente dos dados.
- **Responsabilidades:**
  - Garantir integridade e consistência (ACID).
  - Disponibilidade e segurança das memórias e seus metadados.
  - Suporte robusto à estrutura relacional.

## Conclusão: Princípios da Visão Lógica Evidenciados

A arquitetura lógica da **Eterna FGA**, expressa no diagrama de implantação, está embasada nos seguintes princípios:

- **Separação de Preocupações (SoC):** Cada camada possui responsabilidades claras.
- **Modularidade:** Componentes independentes que se comunicam por interfaces (HTTPS, TCP).
- **Escalabilidade:** Possibilidade de expansão horizontal de cada camada.
- **Segurança:** Adoção de HTTPS em todas as comunicações sensíveis.
- **Reusabilidade:** Backend desacoplado pode atender múltiplas interfaces no futuro.


## Referências Bibliográficas

IBM CORPORATION. Diagramas de Classes em Modelagem UML. In: IBM Knowledge Center – Rational Software Modeler, v. 7.5.0. Disponível em: https://www.ibm.com/docs/pt-br/rsm/7.5.0?topic=structure-class-diagrams. Acesso em: 07 maio 2025.

BOOCH, Grady; RUMBAUGH, James; JACOBSON, Ivar. UML: Guia do Usuário. 2. ed. Rio de Janeiro: Elsevier, 2006. Capítulo 4 – Diagramas de Classes. Disponível em: https://www.livros1.com.br/pdf-read/livar/UML---GUIA-DO-USU%C3%81RIO.pdf. Acesso em: 09 maio 2025.

## Histórico de Versão

|Versão|Data|Descrição|Autor(es)|Data de revisão|Revisor(es)|
|:-:|:-:|:-:|:-:|:-:|:-:|
|`1.0`|30/06/2025|Adicionando informações sobre o diagrama de classes|[Maria Eduarda](https://github.com/DudaV228)|-|-|
|`2.0`|30/06/2025|Adicionando informações sobre o diagrama de implantação|[Maria Eduarda](https://github.com/DudaV228)|-|-|