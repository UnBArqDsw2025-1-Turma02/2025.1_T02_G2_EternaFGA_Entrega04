# Como está sendo aplicado?

## Reutilização de Componentes na Aplicação EternaFGA

Nossa aplicação React demonstra uma arquitetura bem estruturada baseada na reutilização de componentes. A seguir, detalhamos como a reutilização está sendo implementada:

### 1. Estrutura Modular de Componentes

A aplicação está organizada em componentes reutilizáveis que seguem o princípio da responsabilidade única:

```
src/
├── components/
│   ├── Header.jsx          # Cabeçalho reutilizável
│   ├── MemoryCard.jsx      # Card individual de memória
│   ├── MemoryGallery.jsx   # Galeria que reutiliza MemoryCard
│   ├── MemoryForm.jsx      # Formulário modal reutilizável
│   └── MemoryModal.jsx     # Modal de visualização reutilizável
├── styles/                 # Estilos reutilizáveis
└── data/                   # Dados mockados reutilizáveis
```

### 2. Componente MemoryCard - Exemplo de Reutilização

O `MemoryCard`:

```jsx
function MemoryCard({ onCardClick, ...memoria }) {
  const [isHovered, setIsHovered] = useState(false);
  
  return (
    <div 
      style={{ ...memoryStyles.card, ...(isHovered ? memoryStyles.cardHover : {}) }}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={() => onCardClick(memoria)}
    >
      <div style={memoryStyles.imageContainer}>
        <img src={memoria.imagemUrl} alt={memoria.titulo} 
             style={{...memoryStyles.cardImage, ...(isHovered ? memoryStyles.imageHover : {})}} />
      </div>
      <div style={memoryStyles.cardContent}>
        <h3 style={memoryStyles.cardTitle}>{memoria.titulo}</h3>
        <p style={memoryStyles.cardDescription}>{memoria.descricao}</p>
        <time style={memoryStyles.cardDate}>
          {new Date(memoria.dataEnvio).toLocaleDateString('pt-BR')}
        </time>
      </div>
    </div>
  );
}
```

**Características de Reutilização:**
- Recebe props dinâmicas (`memoria`, `onCardClick`)
- Estado interno gerenciado (`isHovered`)
- Estilos reutilizáveis através de `memoryStyles`
- Comportamento consistente independente dos dados

### 3. MemoryGallery - Reutilização de MemoryCard

O `MemoryGallery` demonstra como um componente pode reutilizar outro:

```jsx
function MemoryGallery({ memorias, onCardClick }) {
    return (
        <div style={memoryStyles.gallery}>
            {memorias.map((memoria) => (
                <MemoryCard key={memoria.id} {...memoria} onCardClick={onCardClick} />
            ))}
        </div>
    );
}
```

**Padrões de Reutilização:**
- Renderização dinâmica baseada em array de dados
- Propagação de props (`onCardClick`) para componentes filhos
- Uso do spread operator para passar todas as propriedades da memória


### 5. Componente App

O `App.jsx` demonstra como os componentes são reutilizados e orquestrados:

```jsx
function App() {
  const [memorias, setMemorias] = useState(mockMemorias);
  const [isFormVisible, setIsFormVisible] = useState(false);
  const [selectedMemory, setSelectedMemory] = useState(null);
  
  const handleAddMemory = (newMemory) => {
    setMemorias([newMemory, ...memorias]);
  };

  const handleCardClick = (memoria) => {
    setSelectedMemory(memoria);
  };

  return (
    <div style={appStyles}>
      <Header onSendMemoryClick={() => setIsFormVisible(true)} />
      
      <main>
        <MemoryGallery memorias={memorias} onCardClick={handleCardClick} />
      </main>

      <MemoryForm 
        isVisible={isFormVisible}
        onClose={() => setIsFormVisible(false)}
        onAddMemory={handleAddMemory}
      />
      
      <MemoryModal 
        memoria={selectedMemory}
        onClose={() => setSelectedMemory(null)}
      />
    </div>
  );
}
```

### 6. Padrões de Reutilização Implementados

#### 6.1 **Props Pattern**
Todos os componentes recebem dados via props, tornando-os independentes e reutilizáveis:

```jsx
// Exemplo no Header
<Header onSendMemoryClick={() => setIsFormVisible(true)} />

// Exemplo no MemoryModal
<MemoryModal memoria={selectedMemory} onClose={handleCloseModal} />
```

#### 6.2 **Composition Pattern**
Componentes são compostos por outros componentes menores:

```jsx
// MemoryGallery composto por múltiplos MemoryCard
{memorias.map((memoria) => (
  <MemoryCard key={memoria.id} {...memoria} onCardClick={onCardClick} />
))}
```

#### 6.3 **Conditional Rendering**
Componentes são renderizados condicionalmente para máxima reutilização:

```jsx
// No MemoryForm
if (!isVisible) return null;

// No MemoryModal  
if (!memoria) return null;
```

#### 6.4 **State Management Pattern**
Estado compartilhado entre componentes através de props:

```jsx
const [memorias, setMemorias] = useState(mockMemorias);
const [selectedMemory, setSelectedMemory] = useState(null);
```

### 7. Benefícios da Reutilização Implementada

1. **Manutenibilidade**: Mudanças em um componente refletem em todos os locais onde é usado
2. **Consistência**: Interface uniforme em toda a aplicação
3. **Produtividade**: Desenvolvimento mais rápido através da reutilização
4. **Testabilidade**: Componentes isolados são mais fáceis de testar
5. **Escalabilidade**: Fácil adição de novas funcionalidades

### 8. Dados Reutilizáveis

Os dados mockados também seguem um padrão reutilizável:

```jsx
export const mockMemorias = [
  {
    id: 1,
    titulo: "Formatura de Engenharia",
    descricao: "Um dia inesquecível, a conclusão de um ciclo...",
    imagemUrl: "https://images.unsplash.com/photo-1523050854058-8df90110c9f1",
    dataEnvio: "2024-12-20",
    tag: "Formatura"
  },
  // ... mais memórias
];
```

Este padrão de dados permite que qualquer componente consuma as informações de forma consistente, garantindo que a estrutura seja mantida independente da fonte dos dados (mock, API, etc.).

## Como Rodar o Projeto

### Pré-requisitos

- Node.js (versão 18 ou superior)
- npm ou yarn
- Git instalado

### Passos para Execução

1. **Clone o repositório:**
```bash
git clone https://github.com/UnBArqDsw2024-2/2025.1_T02_G2_EternaFGA_Entrega04.git
cd 2025.1_T02_G2_EternaFGA_Entrega04
```

2. **Navegue até a pasta do projeto React:**
```bash
cd eterna-FGA
```

3. **Instale as dependências:**
```bash
npm install
# ou
yarn install
```

4. **Execute o projeto:**
```bash
npm run dev
# ou
yarn dev
```

5. **Acesse a aplicação:**
Abra seu navegador e vá para `http://localhost:5173`

### Comandos Disponíveis

```bash
npm run dev      # Inicia o servidor de desenvolvimento
npm run build    # Gera build de produção
npm run lint     # Executa o linter
npm run preview  # Visualiza o build de produção
```

### Estrutura do Projeto

```
eterna-FGA/
├── public/                 # Arquivos públicos
├── src/
│   ├── components/         # Componentes reutilizáveis
│   ├── styles/            # Estilos modulares
│   ├── data/              # Dados mockados
│   ├── App.jsx            # Componente principal
│   └── main.jsx           # Ponto de entrada
├── package.json           # Dependências do projeto
└── vite.config.js        # Configuração do Vite
```

## Histórico de Versão

| Versão | Data | Descrição | Autor(es) | Revisor(es) | Comentário do Revisor |
| :-: | :-: | :-: | :-: | :-: | :-: |
| `1.0` | 04/07/2025  | Criação da docmentação do código, explicando os padroes arquiteturais implementados | Manuella | | |
